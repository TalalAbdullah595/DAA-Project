# -*- coding: utf-8 -*-
"""Algorithm_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sa64esth4Pb8x0XVxCb2B6FEBExE9QrJ
"""

#quick elimination
import matplotlib.pyplot as plt
import time

start_time = time.time()
global iterator
iterator = 0
hull = set()
Output = list()

def findSide(p1, p2, p):
    val = (p[1] - p1[1]) * (p2[0] - p1[0]) - (p2[1] - p1[1]) * (p[0] - p1[0])
    if val > 0:
        return 1
    if val < 0:
        return -1
    return 0

def lineDist(p1, p2, p):
    return abs((p[1] - p1[1]) * (p2[0] - p1[0]) - (p2[1] - p1[1]) * (p[0] - p1[0]))

def quickElimination(a, n, p1, p2, side):
    global iterator  # Declare iterator as global
    fig, ax = plt.subplots()
    for i in range(1, len(a)):
        plt.plot([a[0][0], a[i][0]], [a[0][1], a[i][1]], 'og')
    plt.plot([p1[0], p2[0]], [p1[1], p2[1]], 'og--')
    ind = -1
    max_dist = 0

    for i in range(n):
        plt.plot([p1[0], p2[0]], [p1[1], p2[1]], 'og--')
        plt.plot([p1[0], a[i][0]], [p1[1], a[i][1]], 'ob--')
        plt.plot([p2[0], a[i][0]], [p2[1], a[i][1]], 'ob--')

        temp = lineDist(p1, p2, a[i])
        if (findSide(p1, p2, a[i]) == side) and (temp > max_dist):
            ind = i
            max_dist = temp
    ax.set_title('Convex Hull Construction')
    plt.show()

    if ind == -1:
        hull.add("$".join(map(str, p1)))
        hull.add("$".join(map(str, p2)))
        Output.append([p1, p2])

        fig, ax = plt.subplots()
        for i in range(1, len(a)):
            plt.plot([a[0][0], a[i][0]], [a[0][1], a[i][1]], 'og')
        for idx, element in enumerate(Output):
            x1, x2 = element
            plt.plot([x1[0], x2[0]], [x1[1], x2[1]], 'or-')
        ax.set_title('Convex Hull Construction')
        plt.show()

        return

    quickElimination(a, n, a[ind], p1, -findSide(a[ind], p1, p2))
    quickElimination(a, n, a[ind], p2, -findSide(a[ind], p2, p1))

if __name__ == "__main__":
    a = [
        [1, 1], [2, 3], [3, 2], [2, 1],
        [3, 4], [4, 5], [1, 2], [4, 1],
        [5, 3]
    ]

    n = len(a)
    if (n < 3):
        raise Exception("No. of coordinates should be at least 3. Program terminated.")

    xs, ys = zip(*a)
    plt.scatter(xs, ys)
    for i in range(1, len(a)):
        plt.plot([a[0][0], a[i][0]], [a[0][1], a[i][1]], 'og')
    plt.show()

    quickElimination(a, n, a[0], a[-1], 1)
    quickElimination(a, n, a[0], a[-1], -1)

    print("The points in Convex Hull are:")
    for element in hull:
        x = element.split("$")
        print("(", x[0], ",", x[1], ") ", end=" ")

    end_time = time.time()
    execution_time = end_time - start_time
    print("Execution Time in seconds: ", execution_time)

#Brute force
import matplotlib.pyplot as plt
import itertools

def orientation(p, q, r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if val == 0:
        return 0  # Collinear
    return 1 if val > 0 else 2  # Clockwise or Counterclockwise

def on_segment(p, q, r):
    return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and
            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))

def do_intersect(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True

    if o1 == 0 and on_segment(p1, p2, q1):
        return True

    if o2 == 0 and on_segment(p1, q2, q1):
        return True

    if o3 == 0 and on_segment(p2, p1, q2):
        return True

    if o4 == 0 and on_segment(p2, q1, q2):
        return True

    return False

def draw_graph(points, hull_edges):
    plt.scatter(*zip(*points), color='blue', marker='o')
    for edge in hull_edges:
        plt.plot([points[edge[0]][0], points[edge[1]][0]],
                 [points[edge[0]][1], points[edge[1]][1]], color='red')
    plt.show()

def brute_force_convex_hull(points):
    n = len(points)
    hull_edges = []
    for subset in itertools.combinations(range(n), 2):
        intersect = False
        for i in range(n):
            if i not in subset:
                for j in range(len(hull_edges)):
                    if do_intersect(points[subset[0]], points[subset[1]], points[i], points[j]):
                        intersect = True
                        break
                if intersect:
                    break
        if not intersect:
            hull_edges.append(subset)

    # Add the last point to the convex hull
    last_point = hull_edges[-1][1]
    hull_edges.append((last_point, 0))

    draw_graph(points, hull_edges)
    return hull_edges

# Example usage:
points = [(0, 0), (1, 2), (2, 3), (4, 3), (5, 2), (2, 0)]
hull_edges = brute_force_convex_hull(points)
print("Convex Hull Edges:", hull_edges)

#Graham Scan
import matplotlib.pyplot as plt
from random import randint
from math import atan2
import time

start_time = time.time()
iterator = 0

def scatter_plot(coords, convex_hull=None):
    global iterator
    fig, ax = plt.subplots()
    for i in range(1, len(coords)):
        plt.plot([coords[0][0], coords[i][0]], [coords[0][1], coords[i][1]], 'og')

    if convex_hull is not None:
        for i in range(1, len(convex_hull)):
            if i == len(convex_hull): i = 0
            c0 = convex_hull[i - 1]
            c1 = convex_hull[i]
            plt.plot((c0[0], c1[0]), (c0[1], c1[1]), 'or-')
    ax.set_title('Convex Hull Construction')
    plt.show()

def polar_angle(p0, p1=None):
    if p1 is None:
        p1 = anchor
    y_span = p0[1] - p1[1]
    x_span = p0[0] - p1[0]
    return atan2(y_span, x_span)

def distance(p0, p1=None):
    if p1 is None:
        p1 = anchor
    y_span = p0[1] - p1[1]
    x_span = p0[0] - p1[0]
    return y_span ** 2 + x_span ** 2

def det(p1, p2, p3):
    return (p2[0] - p1[0]) * (p3[1] - p1[1]) \
           - (p2[1] - p1[1]) * (p3[0] - p1[0])

def quicksort(a):
    if len(a) <= 1:
        return a
    smaller, equal, larger = [], [], []
    piv_ang = polar_angle(a[randint(0, len(a) - 1)])
    for pt in a:
        pt_ang = polar_angle(pt)
        if pt_ang < piv_ang:
            smaller.append(pt)
        elif pt_ang == piv_ang:
            equal.append(pt)
        else:
            larger.append(pt)
    return quicksort(smaller) \
           + sorted(equal, key=distance) \
           + quicksort(larger)

def graham_scan(points, show_progress=False):
    global anchor
    min_idx = None
    for i, (x, y) in enumerate(points):
        if min_idx is None or y < points[min_idx][1]:
            min_idx = i
        if y == points[min_idx][1] and x < points[min_idx][0]:
            min_idx = i

    anchor = points[min_idx]

    sorted_pts = quicksort(points)
    del sorted_pts[sorted_pts.index(anchor)]

    hull = [anchor, sorted_pts[0]]  # first two points in hull
    for s in sorted_pts[1:]:
        while det(hull[-2], hull[-1], s) <= 0:  # determinant of stack (top, 2nd top, next sorted point) if <= 0 clockwise turn.
            del hull[-1]
        hull.append(s)
        if show_progress: scatter_plot(points, hull)
        hull.append(anchor)
    return hull

if __name__ == "__main__":
    a = [
        [4, 7], [2, 3], [6, 1], [8, 5],
        [6, 7], [2, 5], [4, 1], [8, 3],
        [7, 5], [7, 3]
    ]

    n = len(a)
    if n < 3:
        raise Exception("No. of coordinates should be at least 3. Program terminated.")

    xs, ys = zip(*a)
    plt.scatter(xs, ys)
    for i in range(1, len(a)):
        plt.plot([a[0][0], a[i][0]], [a[0][1], a[i][1]], 'og')
    plt.show()

    hull = graham_scan(a, True)
    scatter_plot(a, hull)

    print("The points in Convex Hull are:")
    print(hull)
    end_time = time.time()
    execution_time = end_time - start_time
    print("Execution Time in seconds: ",execution_time)

#Jarvis March
import matplotlib.pyplot as plt
import time

start_time = time.time()
iterator = 0

def scatter_plot(coords, hull=None):
    global iterator
    fig, ax = plt.subplots()
    for i in range(1, len(coords)):
        plt.plot([coords[0][0], coords[i][0]], [coords[0][1], coords[i][1]], 'og')

    if hull is not None:
        hull_xs, hull_ys = zip(*hull)
        plt.plot(hull_xs + (hull_xs[0],), hull_ys + (hull_ys[0],), 'or-')  # Connect the last point to the first point

        ax.set_title('Convex Hull Construction')
        plt.show()

def jarvis_march(points, show_progress=False):
    n = len(points)

    hull = []
    l = 0
    for i in range(1, n):
        if points[i][1] < points[l][1] or (points[i][1] == points[l][1] and points[i][0] < points[l][0]):
            l = i

    p = l
    while True:
        hull.append(points[p])
        q = (p + 1) % n
        for i in range(n):
            if orientation(points[p], points[i], points[q]) == 2:
                q = i

        p = q

        if p == l:
            break

        if show_progress:
            scatter_plot(points, [points[p], *hull])

    return hull

def orientation(p, q, r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    if val == 0:
        return 0  # Collinear
    return 1 if val > 0 else 2  # Clockwise or Counterclockwise

if __name__ == "__main__":
    a = [
        [4, 7], [2, 3], [6, 1], [8, 5],
        [6, 7], [2, 5], [4, 1], [8, 3],
        [7, 5], [7, 3]
    ]

    n = len(a)
    if n < 3:
        raise Exception("No. of coordinates should be at least 3. Program terminated.")

    xs, ys = zip(*a)
    plt.scatter(xs, ys)
    for i in range(1, len(a)):
        plt.plot([a[0][0], a[i][0]], [a[0][1], a[i][1]], 'og')
    plt.show()

    hull = jarvis_march(a, True)
    scatter_plot(a, hull)

    print("The points in Convex Hull are:")
    print(hull)
    end_time = time.time()
    execution_time = end_time - start_time
    print("Execution Time in seconds: ",execution_time)

#Monotone Chain
import matplotlib.pyplot as plt
import time

start_time = time.time()

iterator = 0



def scatter_plot(coords, convex_hull=None):
    global iterator
    fig, ax = plt.subplots()
    for i in range(1, len(coords)):
        plt.plot([coords[0][0], coords[i][0]], [coords[0][1], coords[i][1]], 'og')

    if convex_hull is not None:
        for i in range(1, len(convex_hull)):
            if i == len(convex_hull): i = 0
            c0 = convex_hull[i - 1]
            c1 = convex_hull[i]
            plt.plot((c0[0], c1[0]), (c0[1], c1[1]), 'or-')
    ax.set_title('Convex Hull Construction')
    plt.show()

def monotone_chain(points, show_progress=False):
    points.sort()  # Sort points

    def build_hull(pts):
        hull = []
        for pt in pts:
            while len(hull) >= 2 and det(hull[-2], hull[-1], pt) <= 0:
                hull.pop()
            hull.append(pt)
            if show_progress:
                scatter_plot(points, hull)
        return hull

    upper_hull = build_hull(points)
    lower_hull = build_hull(points[::-1])

    return upper_hull[:-1] + lower_hull[:-1]

def det(p1, p2, p3):
    return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])

if __name__ == "__main__":
    a = [
        [1, 1], [2, 3], [3, 2], [2, 1],
        [3, 4], [4, 5], [1, 2], [4, 1],
        [5, 3]
    ]

    n = len(a)
    if n < 3:
        raise Exception("No. of coordinates should be at least 3. Program terminated.")

    xs, ys = zip(*a)
    plt.scatter(xs, ys)
    for i in range(1, len(a)):
        plt.plot([a[0][0], a[i][0]], [a[0][1], a[i][1]], 'og')
    plt.show()

    hull = monotone_chain(a, True)
    hull.append(a[0])
    scatter_plot(a, hull)

    print("The points in Convex Hull are:")
    print(hull)
    end_time = time.time()
    execution_time = end_time - start_time
    print("Execution Time in seconds: ",execution_time)

import matplotlib.pyplot as plt
import time


start_time = time.time()

def do_intersect_endpoints(p1, q1, p2, q2):
    def orientation(p, q, r):
        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
        if val == 0:
            return 0  # colinear
        return 1 if val > 0 else 2  # 1 for clockwise, 2 for counterclockwise

    def on_segment(p, q, r):
        return (
            (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0])) and
            (q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))
        )

    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True

    if o1 == 0 and on_segment(p1, p2, q1):
        return True
    if o2 == 0 and on_segment(p1, q2, q1):
        return True
    if o3 == 0 and on_segment(p2, p1, q2):
        return True
    if o4 == 0 and on_segment(p2, q1, q2):
        return True

    return False

def plot_with_status(line, title):
    plt.plot(*zip(*line), label='Line', color='blue')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.title(title)
    if do_intersect_endpoints(line1[0], line1[1], line2[0], line2[1]):
        plt.scatter(*zip(*[line1[0], line1[1], line2[0], line2[1]]), color='red', label='Intersection Points')
        plt.text(0.5, -0.2, "Intersecting", horizontalalignment='center', verticalalignment='center', transform=plt.gca().transAxes, color='red')
    else:
        plt.text(0.5, -0.2, "Not Intersecting", horizontalalignment='center', verticalalignment='center', transform=plt.gca().transAxes, color='green')
    plt.legend()

line1 = [(0, 0), (5, 5)]
line2 = [(0, 4), (4, 0)]

plt.subplot(1, 1, 1)
plot_with_status(line1, 'Endpoint Comparison')
plot_with_status(line2, 'Endpoint Comparison')
plt.tight_layout()
plt.show()
end_time = time.time()
execution_time = end_time - start_time
print("Execution Time in seconds: ",execution_time)